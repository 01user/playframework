/*
 * Copyright (C) 2009-2013 Typesafe Inc. <http://www.typesafe.com>
 */
package play.routes.compiler

import java.io.File
import org.apache.commons.io.FileUtils
import scala.io.Codec

/**
 * provides a compiler for routes
 */
object RoutesCompiler {

  private val LineMarker = "\\s*// @LINE:\\s*(\\d+)\\s*".r

  /**
   * A source file that's been generated by the routes compiler
   */
  trait GeneratedSource {

    /**
     * The original source file associated with this generated source file, if known
     */
    def source: Option[File]

    /**
     * Map the generated line to the original source file line, if known
     */
    def mapLine(generatedLine: Int): Option[Int]
  }

  object GeneratedSource {

    def unapply(file: File): Option[GeneratedSource] = {

      val lines: Array[String] = if (file.exists) {
        FileUtils.readFileToString(file, implicitly[Codec].name).split('\n')
      } else {
        Array.empty[String]
      }

      if (lines.contains("// @GENERATOR:play-routes-compiler")) {
        Some(new GeneratedSource {
          val source: Option[File] =
            lines.find(_.startsWith("// @SOURCE:")).map(m => new File(m.trim.drop(11)))

          def mapLine(generatedLine: Int): Option[Int] = {
            lines.view.take(generatedLine).reverse.collectFirst {
              case LineMarker(line) => Integer.parseInt(line)
            }
          }
        })
      } else {
        None
      }
    }

  }

  /**
   * Compile the given routes file
   *
   * @param file The routes file to compile
   * @param generatedDir The directory to place the generated source code in
   * @param additionalImports Additional imports to add to the output files
   * @param generateReverseRouter Whether the reverse router should be generated
   * @param generateRefReverseRouter Whether the ref router should be generated
   * @param namespaceReverseRouter Whether the reverse router should be namespaced
   * @return Either the list of files that were generated (right) or the routes compilation errors (left)
   */
  def compile(file: File, generatedDir: File, additionalImports: Seq[String], generateReverseRouter: Boolean = true,
    generateRefReverseRouter: Boolean = true, namespaceReverseRouter: Boolean = false): Either[Seq[RoutesCompilationError], Seq[File]] = {

    val namespace = Option(file.getName).filter(_.endsWith(".routes")).map(_.dropRight(".routes".size))

    val routeFile = file.getAbsoluteFile

    RoutesFileParser.parse(routeFile).right.map { rules =>
      val generated = generate(routeFile, namespace, rules, additionalImports, generateReverseRouter,
        generateRefReverseRouter, namespaceReverseRouter)
      generated.map {
        case (filename, content) =>
          val file = new File(generatedDir, filename)
          FileUtils.writeStringToFile(file, content, implicitly[Codec].name)
          file
      }
    }
  }

  /**
   * Generate the actual Scala code for this router
   */
  private def generate(file: File, namespace: Option[String], rules: List[Rule], additionalImports: Seq[String], reverseRouter: Boolean, reverseRefRouter: Boolean, namespaceReverseRouter: Boolean): Seq[(String, String)] = {

    val filePrefix = namespace.map(_.replace('.', '/') + "/").getOrElse("") + "/routes"

    val sourceInfo = RoutesSourceInfo(file.getCanonicalPath.replace(File.separator, "/"), new java.util.Date().toString)
    val routes = rules.collect { case r: Route => r }

    val files = Seq(filePrefix + "_routing.scala" -> generateRouter(sourceInfo, namespace, additionalImports, rules))
    if (reverseRouter) {
      (files :+ filePrefix + "_reverseRouting.scala" -> generateReverseRouter(sourceInfo, namespace, additionalImports, routes, reverseRefRouter, namespaceReverseRouter)) ++
        generateJavaWrappers(sourceInfo, rules, reverseRefRouter, namespace.filter(_ => namespaceReverseRouter))
    } else {
      files
    }
  }

  def generateRouter(sourceInfo: RoutesSourceInfo, namespace: Option[String], additionalImports: Seq[String], rules: List[Rule]) =
    static.twirl.forwardsRouter(
      sourceInfo,
      namespace,
      additionalImports,
      rules,
      rules.collect { case i: Include => i }
    ).body

  def generateReverseRouter(sourceInfo: RoutesSourceInfo, namespace: Option[String], additionalImports: Seq[String], routes: List[Route], reverseRefRouter: Boolean, namespaceReverseRouter: Boolean) =
    static.twirl.reverseRouters(
      sourceInfo,
      namespace,
      additionalImports,
      routes,
      namespaceReverseRouter,
      reverseRefRouter
    ).body

  def generateJavaWrappers(sourceInfo: RoutesSourceInfo, rules: List[Rule], reverseRefRouter: Boolean, namespace: Option[String]) = {
    rules.collect { case r: Route => r }.groupBy(_.call.packageName).map {
      case (pn, routes) =>
        val packageName = namespace.map(_ + "." + pn).getOrElse(pn)
        val controllers = routes.groupBy(_.call.controller).keys.toSeq

        (packageName.replace(".", "/") + "/routes.java") ->
          static.twirl.javaWrappers(sourceInfo, packageName, controllers, reverseRefRouter).body
    }
  }

}

